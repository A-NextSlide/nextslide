#!/usr/bin/env node
/*
  Helper script (manual step):
  - Place downloaded Unblast font files under public/fonts/unblast/{FontName}/{files}
  - This script will scan and propose FontDefinition entries for local usage
*/
const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const FONTS_DIR = path.join(ROOT, 'public', 'fonts');
const OUTPUT_TS = path.join(ROOT, 'src', 'registry', 'library', 'unblast-local.ts');

function inferWeightFromFilename(filename) {
  const lower = filename.toLowerCase();
  if (lower.includes('black') || lower.includes('900')) return '900';
  if (lower.includes('extrabold') || lower.includes('800')) return '800';
  if (lower.includes('bold') || lower.includes('700')) return '700';
  if (lower.includes('semibold') || lower.includes('demibold') || lower.includes('600')) return '600';
  if (lower.includes('medium') || lower.includes('500')) return '500';
  if (lower.includes('light') || lower.includes('300')) return '300';
  if (lower.includes('thin') || lower.includes('100')) return '100';
  return '400';
}

function inferStyleFromFilename(filename) {
  const lower = filename.toLowerCase();
  if (lower.includes('italic')) return 'italic';
  return 'normal';
}

// Walk up from file directory to find a plausible family folder name
function inferFamilyFromPath(fullPath) {
  const parts = fullPath.split(path.sep);
  // Find index of 'public' then 'fonts'
  const pubIdx = parts.lastIndexOf('public');
  let startIdx = pubIdx >= 0 ? pubIdx + 2 : Math.max(0, parts.length - 3); // after 'public','fonts'
  // Walk up to find a non-generic folder
  const generic = new Set(['files','otf','ttf','woff','woff2','fonts','font','hf','hf lonehope otf','hf hunos otf','hf pensional otf','hf pensional ttf woff woff2','hf lonehope ttf, woff, woff2','hf hunos ttf woff woff2']);
  for (let i = parts.length - 2; i >= startIdx; i--) {
    const name = parts[i].replace(/_/g, ' ').trim();
    const lower = name.toLowerCase();
    if (!generic.has(lower) && !/\.(otf|ttf|woff2?|zip)$/i.test(lower) && name.length > 1) {
      return name;
    }
  }
  // Fallback to filename stem before '-' or first space
  const base = path.basename(fullPath).replace(/\.(otf|ttf|woff2?|zip)$/i, '');
  return base.split(/[-_]/)[0].trim();
}

function walk(dir, acc) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (e.name.startsWith('.')) continue;
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      walk(full, acc);
    } else if (/\.(woff2|woff|otf|ttf)$/i.test(e.name)) {
      acc.push(full);
    }
  }
}

function main() {
  if (!fs.existsSync(FONTS_DIR)) {
    console.error(`No directory: ${FONTS_DIR}`);
    process.exit(1);
  }

  const files = [];
  walk(FONTS_DIR, files);
  const defs = [];
  const seen = new Set();

  for (const full of files) {
    // Build URL from /public root
    const rel = full.split(path.join(ROOT, 'public'))[1];
    const url = rel.replace(/\\/g, '/');
    const fname = path.basename(full);
    const family = inferFamilyFromPath(full);
    const weight = inferWeightFromFilename(fname);
    const style = inferStyleFromFilename(fname);
    const key = `${family}|${weight}|${style}|${url}`;
    if (seen.has(key)) continue;
    seen.add(key);
    defs.push({ name: family, family: family, source: 'local', weight, style, url });
  }

  const header = `import type { FontDefinition } from './fonts';\n\n// Generated by scripts/import-unblast-fonts.js\nexport const UNBLAST_LOCAL_FONTS: FontDefinition[] = `;
  const body = JSON.stringify(defs, null, 2);
  fs.writeFileSync(OUTPUT_TS, `${header}${body};\n`);
  console.log(`Wrote ${defs.length} local font entries to ${OUTPUT_TS}`);
}

main();


