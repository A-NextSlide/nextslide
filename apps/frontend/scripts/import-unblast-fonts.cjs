#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const FONTS_DIR = path.join(ROOT, 'public', 'fonts');
const OUTPUT_TS = path.join(ROOT, 'src', 'registry', 'library', 'unblast-local.ts');

function inferWeightFromFilename(filename) {
  const lower = filename.toLowerCase();
  if (lower.includes('black') || lower.includes('900')) return '900';
  if (lower.includes('extrabold') || lower.includes('800')) return '800';
  if (lower.includes('bold') || lower.includes('700')) return '700';
  if (lower.includes('semibold') || lower.includes('demibold') || lower.includes('600')) return '600';
  if (lower.includes('medium') || lower.includes('500')) return '500';
  if (lower.includes('light') || lower.includes('300')) return '300';
  if (lower.includes('thin') || lower.includes('100')) return '100';
  return '400';
}

function inferStyleFromFilename(filename) {
  const lower = filename.toLowerCase();
  if (lower.includes('italic')) return 'italic';
  return 'normal';
}

function inferFamilyFromPath(fullPath) {
  const parts = fullPath.split(path.sep);
  const pubIdx = parts.lastIndexOf('public');
  const fontsIdx = parts.lastIndexOf('fonts');
  const startIdx = fontsIdx >= 0 ? fontsIdx + 1 : (pubIdx >= 0 ? pubIdx + 1 : 0);
  // Walk up to find a non-generic folder name
  const generic = new Set(['files','otf','ttf','woff','woff2','fonts','font','hf','hf lonehope otf','hf hunos otf','hf pensional otf','hf pensional ttf woff woff2','hf lonehope ttf, woff, woff2','hf hunos ttf woff woff2','otf files','ttf files']);
  for (let i = parts.length - 2; i >= startIdx; i--) {
    const name = parts[i].replace(/_/g, ' ').trim();
    const lower = name.toLowerCase();
    if (!generic.has(lower) && name.length > 1) {
      return name;
    }
  }
  const base = path.basename(fullPath).replace(/\.(otf|ttf|woff2?|zip)$/i, '');
  return base.split(/[-_]/)[0].trim();
}

function walk(dir, acc) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (e.name.startsWith('.')) continue;
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      walk(full, acc);
    } else if (/\.(woff2|woff|otf|ttf)$/i.test(e.name)) {
      acc.push(full);
    }
  }
}

function main() {
  if (!fs.existsSync(FONTS_DIR)) {
    console.error(`No directory: ${FONTS_DIR}`);
    process.exit(1);
  }

  const files = [];
  walk(FONTS_DIR, files);
  const defs = [];
  const seen = new Set();

  for (const full of files) {
    const rel = full.split(path.join(ROOT, 'public'))[1].replace(/\\/g, '/');
    const url = rel.startsWith('/') ? rel : `/${rel}`;
    const fname = path.basename(full);
    let family = inferFamilyFromPath(full);
    // Clean up noisy family names (remove numeric prefixes, vendor tags, and copy suffixes like (1))
    family = family.replace(/^\d+[_-]?/,'').replace(/\s{2,}/g,' ').trim();
    family = family.replace(/\b(hf|files|otf|ttf|woff2|woff)\b/gi,'').replace(/\s{2,}/g,' ').trim();
    family = family.replace(/\s*\(\d+\)\s*$/,'').trim();
    const weight = inferWeightFromFilename(fname);
    const style = inferStyleFromFilename(fname);
    const key = `${family}|${weight}|${style}|${url}`;
    if (seen.has(key)) continue;
    seen.add(key);
    defs.push({ name: family, family: family, source: 'local', weight, style, url });
  }

  const header = `import type { FontDefinition } from './fonts';\n\n// Generated by scripts/import-unblast-fonts.cjs\nexport const UNBLAST_LOCAL_FONTS: FontDefinition[] = `;
  // De-duplicate by same family+weight+style; prefer woff2 > woff > otf > ttf
  const pref = { woff2: 4, woff: 3, otf: 2, ttf: 1 };
  const pick = new Map();
  for (const d of defs) {
    const ext = (d.url.split('.').pop() || '').toLowerCase();
    const key = `${d.family}|${d.weight}|${d.style}`;
    const prev = pick.get(key);
    if (!prev) pick.set(key, d);
    else {
      const pext = (prev.url.split('.').pop() || '').toLowerCase();
      if ((pref[ext] || 0) > (pref[pext] || 0)) pick.set(key, d);
    }
  }
  const minimized = Array.from(pick.values());
  const body = JSON.stringify(minimized, null, 2);
  fs.writeFileSync(OUTPUT_TS, `${header}${body};\n`);
  console.log(`Wrote ${defs.length} local font entries to ${OUTPUT_TS}`);
}

main();


